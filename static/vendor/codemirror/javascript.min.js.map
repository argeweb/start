{"version":3,"sources":["../../bower_components/codemirror/mode/javascript/javascript.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","expressionAllowed","stream","state","backUp","test","lastType","string","slice","pos","defineMode","config","parserConfig","readRegexp","next","escaped","inSet","ret","tp","style","cont","type","content","tokenBase","ch","tokenize","tokenString","match","eat","eatWhile","tokenComment","skipToEnd","isOperatorChar","current","tokenQuasi","wordRE","word","known","keywords","propertyIsEnumerable","quote","jsonldMode","peek","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","start","depth","sawSomething","charAt","bracket","brackets","JSLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","lexical","hasOwnProperty","combinator","length","pop","jsonMode","expression","statement","lex","pass","i","arguments","push","apply","register","inList","list","globalVars","pushcontext","defaultVars","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","className","afterExport","afterImport","pattern","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","continueQuasi","targetNoComma","target","_","getterSetter","afterprop","what","end","proceed","maybetype","isTS","typeexpr","maybedefault","afterType","typeprop","typearg","maybeReturnType","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeAs","isContinuedStatement","textAfter","indentUnit","statementIndent","jsonld","json","typescript","wordCharacters","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","class","super","yield","export","import","extends","await","async","tsKeywords","interface","implements","namespace","enum","public","private","protected","abstract","as","number","boolean","any","attr","variable","regexp","jsonld-keyword","startState","basecolumn","token","sol","indentation","eatSpace","Pass","firstChar","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","lineComment","fold","closeBrackets","helperType","skipExpression","top","registerHelper","defineMIME"],"mappings":"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","file":"javascript.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\r\n    mod(require(\"../../lib/codemirror\"));\r\n  else if (typeof define == \"function\" && define.amd) // AMD\r\n    define([\"../../lib/codemirror\"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n\"use strict\";\r\n\r\nfunction expressionAllowed(stream, state, backUp) {\r\n  return /^(?:operator|sof|keyword c|case|new|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\r\n    (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\r\n}\r\n\r\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\r\n  var indentUnit = config.indentUnit;\r\n  var statementIndent = parserConfig.statementIndent;\r\n  var jsonldMode = parserConfig.jsonld;\r\n  var jsonMode = parserConfig.json || jsonldMode;\r\n  var isTS = parserConfig.typescript;\r\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\r\n\r\n  // Tokenizer\r\n\r\n  var keywords = function(){\r\n    function kw(type) {return {type: type, style: \"keyword\"};}\r\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\r\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\r\n\r\n    var jsKeywords = {\r\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\r\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\r\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\r\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\r\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\r\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\r\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\r\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\r\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\r\n      \"await\": C, \"async\": kw(\"async\")\r\n    };\r\n\r\n    // Extend the 'normal' keywords with the TypeScript language extensions\r\n    if (isTS) {\r\n      var type = {type: \"variable\", style: \"variable-3\"};\r\n      var tsKeywords = {\r\n        // object-like things\r\n        \"interface\": kw(\"class\"),\r\n        \"implements\": C,\r\n        \"namespace\": C,\r\n        \"module\": kw(\"module\"),\r\n        \"enum\": kw(\"module\"),\r\n\r\n        // scope modifiers\r\n        \"public\": kw(\"modifier\"),\r\n        \"private\": kw(\"modifier\"),\r\n        \"protected\": kw(\"modifier\"),\r\n        \"abstract\": kw(\"modifier\"),\r\n\r\n        // operators\r\n        \"as\": operator,\r\n\r\n        // types\r\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\r\n      };\r\n\r\n      for (var attr in tsKeywords) {\r\n        jsKeywords[attr] = tsKeywords[attr];\r\n      }\r\n    }\r\n\r\n    return jsKeywords;\r\n  }();\r\n\r\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\r\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\r\n\r\n  function readRegexp(stream) {\r\n    var escaped = false, next, inSet = false;\r\n    while ((next = stream.next()) != null) {\r\n      if (!escaped) {\r\n        if (next == \"/\" && !inSet) return;\r\n        if (next == \"[\") inSet = true;\r\n        else if (inSet && next == \"]\") inSet = false;\r\n      }\r\n      escaped = !escaped && next == \"\\\\\";\r\n    }\r\n  }\r\n\r\n  // Used as scratch variables to communicate multiple values without\r\n  // consing up tons of objects.\r\n  var type, content;\r\n  function ret(tp, style, cont) {\r\n    type = tp; content = cont;\r\n    return style;\r\n  }\r\n  function tokenBase(stream, state) {\r\n    var ch = stream.next();\r\n    if (ch == '\"' || ch == \"'\") {\r\n      state.tokenize = tokenString(ch);\r\n      return state.tokenize(stream, state);\r\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \".\" && stream.match(\"..\")) {\r\n      return ret(\"spread\", \"meta\");\r\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\r\n      return ret(ch);\r\n    } else if (ch == \"=\" && stream.eat(\">\")) {\r\n      return ret(\"=>\", \"operator\");\r\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\r\n      stream.eatWhile(/[\\da-f]/i);\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\r\n      stream.eatWhile(/[0-7]/i);\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\r\n      stream.eatWhile(/[01]/i);\r\n      return ret(\"number\", \"number\");\r\n    } else if (/\\d/.test(ch)) {\r\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\r\n      return ret(\"number\", \"number\");\r\n    } else if (ch == \"/\") {\r\n      if (stream.eat(\"*\")) {\r\n        state.tokenize = tokenComment;\r\n        return tokenComment(stream, state);\r\n      } else if (stream.eat(\"/\")) {\r\n        stream.skipToEnd();\r\n        return ret(\"comment\", \"comment\");\r\n      } else if (expressionAllowed(stream, state, 1)) {\r\n        readRegexp(stream);\r\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\r\n        return ret(\"regexp\", \"string-2\");\r\n      } else {\r\n        stream.eatWhile(isOperatorChar);\r\n        return ret(\"operator\", \"operator\", stream.current());\r\n      }\r\n    } else if (ch == \"`\") {\r\n      state.tokenize = tokenQuasi;\r\n      return tokenQuasi(stream, state);\r\n    } else if (ch == \"#\") {\r\n      stream.skipToEnd();\r\n      return ret(\"error\", \"error\");\r\n    } else if (isOperatorChar.test(ch)) {\r\n      stream.eatWhile(isOperatorChar);\r\n      return ret(\"operator\", \"operator\", stream.current());\r\n    } else if (wordRE.test(ch)) {\r\n      stream.eatWhile(wordRE);\r\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\r\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\r\n                     ret(\"variable\", \"variable\", word);\r\n    }\r\n  }\r\n\r\n  function tokenString(quote) {\r\n    return function(stream, state) {\r\n      var escaped = false, next;\r\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\r\n        state.tokenize = tokenBase;\r\n        return ret(\"jsonld-keyword\", \"meta\");\r\n      }\r\n      while ((next = stream.next()) != null) {\r\n        if (next == quote && !escaped) break;\r\n        escaped = !escaped && next == \"\\\\\";\r\n      }\r\n      if (!escaped) state.tokenize = tokenBase;\r\n      return ret(\"string\", \"string\");\r\n    };\r\n  }\r\n\r\n  function tokenComment(stream, state) {\r\n    var maybeEnd = false, ch;\r\n    while (ch = stream.next()) {\r\n      if (ch == \"/\" && maybeEnd) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      maybeEnd = (ch == \"*\");\r\n    }\r\n    return ret(\"comment\", \"comment\");\r\n  }\r\n\r\n  function tokenQuasi(stream, state) {\r\n    var escaped = false, next;\r\n    while ((next = stream.next()) != null) {\r\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\r\n        state.tokenize = tokenBase;\r\n        break;\r\n      }\r\n      escaped = !escaped && next == \"\\\\\";\r\n    }\r\n    return ret(\"quasi\", \"string-2\", stream.current());\r\n  }\r\n\r\n  var brackets = \"([{}])\";\r\n  // This is a crude lookahead trick to try and notice that we're\r\n  // parsing the argument patterns for a fat-arrow function before we\r\n  // actually hit the arrow token. It only works if the arrow is on\r\n  // the same line as the arguments and there's no strange noise\r\n  // (comments) in between. Fallback is to only notice when we hit the\r\n  // arrow, and not declare the arguments as locals for the arrow\r\n  // body.\r\n  function findFatArrow(stream, state) {\r\n    if (state.fatArrowAt) state.fatArrowAt = null;\r\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\r\n    if (arrow < 0) return;\r\n\r\n    var depth = 0, sawSomething = false;\r\n    for (var pos = arrow - 1; pos >= 0; --pos) {\r\n      var ch = stream.string.charAt(pos);\r\n      var bracket = brackets.indexOf(ch);\r\n      if (bracket >= 0 && bracket < 3) {\r\n        if (!depth) { ++pos; break; }\r\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\r\n      } else if (bracket >= 3 && bracket < 6) {\r\n        ++depth;\r\n      } else if (wordRE.test(ch)) {\r\n        sawSomething = true;\r\n      } else if (/[\"'\\/]/.test(ch)) {\r\n        return;\r\n      } else if (sawSomething && !depth) {\r\n        ++pos;\r\n        break;\r\n      }\r\n    }\r\n    if (sawSomething && !depth) state.fatArrowAt = pos;\r\n  }\r\n\r\n  // Parser\r\n\r\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\r\n\r\n  function JSLexical(indented, column, type, align, prev, info) {\r\n    this.indented = indented;\r\n    this.column = column;\r\n    this.type = type;\r\n    this.prev = prev;\r\n    this.info = info;\r\n    if (align != null) this.align = align;\r\n  }\r\n\r\n  function inScope(state, varname) {\r\n    for (var v = state.localVars; v; v = v.next)\r\n      if (v.name == varname) return true;\r\n    for (var cx = state.context; cx; cx = cx.prev) {\r\n      for (var v = cx.vars; v; v = v.next)\r\n        if (v.name == varname) return true;\r\n    }\r\n  }\r\n\r\n  function parseJS(state, style, type, content, stream) {\r\n    var cc = state.cc;\r\n    // Communicate our context to the combinators.\r\n    // (Less wasteful than consing up a hundred closures on every call.)\r\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\r\n\r\n    if (!state.lexical.hasOwnProperty(\"align\"))\r\n      state.lexical.align = true;\r\n\r\n    while(true) {\r\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\r\n      if (combinator(type, content)) {\r\n        while(cc.length && cc[cc.length - 1].lex)\r\n          cc.pop()();\r\n        if (cx.marked) return cx.marked;\r\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\r\n        return style;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Combinator utils\r\n\r\n  var cx = {state: null, column: null, marked: null, cc: null};\r\n  function pass() {\r\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\r\n  }\r\n  function cont() {\r\n    pass.apply(null, arguments);\r\n    return true;\r\n  }\r\n  function register(varname) {\r\n    function inList(list) {\r\n      for (var v = list; v; v = v.next)\r\n        if (v.name == varname) return true;\r\n      return false;\r\n    }\r\n    var state = cx.state;\r\n    cx.marked = \"def\";\r\n    if (state.context) {\r\n      if (inList(state.localVars)) return;\r\n      state.localVars = {name: varname, next: state.localVars};\r\n    } else {\r\n      if (inList(state.globalVars)) return;\r\n      if (parserConfig.globalVars)\r\n        state.globalVars = {name: varname, next: state.globalVars};\r\n    }\r\n  }\r\n\r\n  // Combinators\r\n\r\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\r\n  function pushcontext() {\r\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\r\n    cx.state.localVars = defaultVars;\r\n  }\r\n  function popcontext() {\r\n    cx.state.localVars = cx.state.context.vars;\r\n    cx.state.context = cx.state.context.prev;\r\n  }\r\n  function pushlex(type, info) {\r\n    var result = function() {\r\n      var state = cx.state, indent = state.indented;\r\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\r\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\r\n        indent = outer.indented;\r\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\r\n    };\r\n    result.lex = true;\r\n    return result;\r\n  }\r\n  function poplex() {\r\n    var state = cx.state;\r\n    if (state.lexical.prev) {\r\n      if (state.lexical.type == \")\")\r\n        state.indented = state.lexical.indented;\r\n      state.lexical = state.lexical.prev;\r\n    }\r\n  }\r\n  poplex.lex = true;\r\n\r\n  function expect(wanted) {\r\n    function exp(type) {\r\n      if (type == wanted) return cont();\r\n      else if (wanted == \";\") return pass();\r\n      else return cont(exp);\r\n    };\r\n    return exp;\r\n  }\r\n\r\n  function statement(type, value) {\r\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\r\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\r\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\r\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\r\n    if (type == \";\") return cont();\r\n    if (type == \"if\") {\r\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\r\n        cx.state.cc.pop()();\r\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\r\n    }\r\n    if (type == \"function\") return cont(functiondef);\r\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\r\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\r\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\r\n                                      block, poplex, poplex);\r\n    if (type == \"case\") return cont(expression, expect(\":\"));\r\n    if (type == \"default\") return cont(expect(\":\"));\r\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\r\n                                     statement, poplex, popcontext);\r\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\r\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\r\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\r\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, pushlex(\"}\"), expect(\"{\"), block, poplex, poplex)\r\n    if (type == \"async\") return cont(statement)\r\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\r\n  }\r\n  function expression(type) {\r\n    return expressionInner(type, false);\r\n  }\r\n  function expressionNoComma(type) {\r\n    return expressionInner(type, true);\r\n  }\r\n  function expressionInner(type, noComma) {\r\n    if (cx.state.fatArrowAt == cx.stream.start) {\r\n      var body = noComma ? arrowBodyNoComma : arrowBody;\r\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\r\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\r\n    }\r\n\r\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\r\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\r\n    if (type == \"function\") return cont(functiondef, maybeop);\r\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\r\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\r\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\r\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\r\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\r\n    if (type == \"quasi\") return pass(quasi, maybeop);\r\n    if (type == \"new\") return cont(maybeTarget(noComma));\r\n    return cont();\r\n  }\r\n  function maybeexpression(type) {\r\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\r\n    return pass(expression);\r\n  }\r\n  function maybeexpressionNoComma(type) {\r\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\r\n    return pass(expressionNoComma);\r\n  }\r\n\r\n  function maybeoperatorComma(type, value) {\r\n    if (type == \",\") return cont(expression);\r\n    return maybeoperatorNoComma(type, value, false);\r\n  }\r\n  function maybeoperatorNoComma(type, value, noComma) {\r\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\r\n    var expr = noComma == false ? expression : expressionNoComma;\r\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\r\n    if (type == \"operator\") {\r\n      if (/\\+\\+|--/.test(value)) return cont(me);\r\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\r\n      return cont(expr);\r\n    }\r\n    if (type == \"quasi\") { return pass(quasi, me); }\r\n    if (type == \";\") return;\r\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\r\n    if (type == \".\") return cont(property, me);\r\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\r\n  }\r\n  function quasi(type, value) {\r\n    if (type != \"quasi\") return pass();\r\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\r\n    return cont(expression, continueQuasi);\r\n  }\r\n  function continueQuasi(type) {\r\n    if (type == \"}\") {\r\n      cx.marked = \"string-2\";\r\n      cx.state.tokenize = tokenQuasi;\r\n      return cont(quasi);\r\n    }\r\n  }\r\n  function arrowBody(type) {\r\n    findFatArrow(cx.stream, cx.state);\r\n    return pass(type == \"{\" ? statement : expression);\r\n  }\r\n  function arrowBodyNoComma(type) {\r\n    findFatArrow(cx.stream, cx.state);\r\n    return pass(type == \"{\" ? statement : expressionNoComma);\r\n  }\r\n  function maybeTarget(noComma) {\r\n    return function(type) {\r\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\r\n      else return pass(noComma ? expressionNoComma : expression);\r\n    };\r\n  }\r\n  function target(_, value) {\r\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\r\n  }\r\n  function targetNoComma(_, value) {\r\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\r\n  }\r\n  function maybelabel(type) {\r\n    if (type == \":\") return cont(poplex, statement);\r\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\r\n  }\r\n  function property(type) {\r\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\r\n  }\r\n  function objprop(type, value) {\r\n    if (type == \"async\") {\r\n      cx.marked = \"property\";\r\n      return cont(objprop);\r\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\r\n      cx.marked = \"property\";\r\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\r\n      return cont(afterprop);\r\n    } else if (type == \"number\" || type == \"string\") {\r\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\r\n      return cont(afterprop);\r\n    } else if (type == \"jsonld-keyword\") {\r\n      return cont(afterprop);\r\n    } else if (type == \"modifier\") {\r\n      return cont(objprop)\r\n    } else if (type == \"[\") {\r\n      return cont(expression, expect(\"]\"), afterprop);\r\n    } else if (type == \"spread\") {\r\n      return cont(expression);\r\n    } else if (type == \":\") {\r\n      return pass(afterprop)\r\n    }\r\n  }\r\n  function getterSetter(type) {\r\n    if (type != \"variable\") return pass(afterprop);\r\n    cx.marked = \"property\";\r\n    return cont(functiondef);\r\n  }\r\n  function afterprop(type) {\r\n    if (type == \":\") return cont(expressionNoComma);\r\n    if (type == \"(\") return pass(functiondef);\r\n  }\r\n  function commasep(what, end) {\r\n    function proceed(type, value) {\r\n      if (type == \",\") {\r\n        var lex = cx.state.lexical;\r\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\r\n        return cont(function(type, value) {\r\n          if (type == end || value == end) return pass()\r\n          return pass(what)\r\n        }, proceed);\r\n      }\r\n      if (type == end || value == end) return cont();\r\n      return cont(expect(end));\r\n    }\r\n    return function(type, value) {\r\n      if (type == end || value == end) return cont();\r\n      return pass(what, proceed);\r\n    };\r\n  }\r\n  function contCommasep(what, end, info) {\r\n    for (var i = 3; i < arguments.length; i++)\r\n      cx.cc.push(arguments[i]);\r\n    return cont(pushlex(end, info), commasep(what, end), poplex);\r\n  }\r\n  function block(type) {\r\n    if (type == \"}\") return cont();\r\n    return pass(statement, block);\r\n  }\r\n  function maybetype(type) {\r\n    if (isTS && type == \":\") return cont(typeexpr);\r\n  }\r\n  function maybedefault(_, value) {\r\n    if (value == \"=\") return cont(expressionNoComma);\r\n  }\r\n  function typeexpr(type) {\r\n    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont(afterType);}\r\n    if (type == \"{\") return cont(commasep(typeprop, \"}\"))\r\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\r\n  }\r\n  function maybeReturnType(type) {\r\n    if (type == \"=>\") return cont(typeexpr)\r\n  }\r\n  function typeprop(type) {\r\n    if (type == \"variable\" || cx.style == \"keyword\") {\r\n      cx.marked = \"property\"\r\n      return cont(typeprop)\r\n    } else if (type == \":\") {\r\n      return cont(typeexpr)\r\n    }\r\n  }\r\n  function typearg(type) {\r\n    if (type == \"variable\") return cont(typearg)\r\n    else if (type == \":\") return cont(typeexpr)\r\n  }\r\n  function afterType(type, value) {\r\n    if (value == \"<\") return cont(commasep(typeexpr, \">\"), afterType)\r\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\r\n  }\r\n  function vardef() {\r\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\r\n  }\r\n  function pattern(type, value) {\r\n    if (type == \"modifier\") return cont(pattern)\r\n    if (type == \"variable\") { register(value); return cont(); }\r\n    if (type == \"spread\") return cont(pattern);\r\n    if (type == \"[\") return contCommasep(pattern, \"]\");\r\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\r\n  }\r\n  function proppattern(type, value) {\r\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\r\n      register(value);\r\n      return cont(maybeAssign);\r\n    }\r\n    if (type == \"variable\") cx.marked = \"property\";\r\n    if (type == \"spread\") return cont(pattern);\r\n    if (type == \"}\") return pass();\r\n    return cont(expect(\":\"), pattern, maybeAssign);\r\n  }\r\n  function maybeAssign(_type, value) {\r\n    if (value == \"=\") return cont(expressionNoComma);\r\n  }\r\n  function vardefCont(type) {\r\n    if (type == \",\") return cont(vardef);\r\n  }\r\n  function maybeelse(type, value) {\r\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\r\n  }\r\n  function forspec(type) {\r\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\r\n  }\r\n  function forspec1(type) {\r\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\r\n    if (type == \";\") return cont(forspec2);\r\n    if (type == \"variable\") return cont(formaybeinof);\r\n    return pass(expression, expect(\";\"), forspec2);\r\n  }\r\n  function formaybeinof(_type, value) {\r\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\r\n    return cont(maybeoperatorComma, forspec2);\r\n  }\r\n  function forspec2(type, value) {\r\n    if (type == \";\") return cont(forspec3);\r\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\r\n    return pass(expression, expect(\";\"), forspec3);\r\n  }\r\n  function forspec3(type) {\r\n    if (type != \")\") cont(expression);\r\n  }\r\n  function functiondef(type, value) {\r\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\r\n    if (type == \"variable\") {register(value); return cont(functiondef);}\r\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\r\n  }\r\n  function funarg(type) {\r\n    if (type == \"spread\") return cont(funarg);\r\n    return pass(pattern, maybetype, maybedefault);\r\n  }\r\n  function className(type, value) {\r\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\r\n  }\r\n  function classNameAfter(type, value) {\r\n    if (value == \"extends\") return cont(isTS ? typeexpr : expression, classNameAfter);\r\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\r\n  }\r\n  function classBody(type, value) {\r\n    if (type == \"variable\" || cx.style == \"keyword\") {\r\n      if (value == \"static\") {\r\n        cx.marked = \"keyword\";\r\n        return cont(classBody);\r\n      }\r\n      cx.marked = \"property\";\r\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\r\n      return cont(functiondef, classBody);\r\n    }\r\n    if (value == \"*\") {\r\n      cx.marked = \"keyword\";\r\n      return cont(classBody);\r\n    }\r\n    if (type == \";\") return cont(classBody);\r\n    if (type == \"}\") return cont();\r\n  }\r\n  function classGetterSetter(type) {\r\n    if (type != \"variable\") return pass();\r\n    cx.marked = \"property\";\r\n    return cont();\r\n  }\r\n  function afterExport(_type, value) {\r\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\r\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\r\n    return pass(statement);\r\n  }\r\n  function afterImport(type) {\r\n    if (type == \"string\") return cont();\r\n    return pass(importSpec, maybeFrom);\r\n  }\r\n  function importSpec(type, value) {\r\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\r\n    if (type == \"variable\") register(value);\r\n    if (value == \"*\") cx.marked = \"keyword\";\r\n    return cont(maybeAs);\r\n  }\r\n  function maybeAs(_type, value) {\r\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\r\n  }\r\n  function maybeFrom(_type, value) {\r\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\r\n  }\r\n  function arrayLiteral(type) {\r\n    if (type == \"]\") return cont();\r\n    return pass(commasep(expressionNoComma, \"]\"));\r\n  }\r\n\r\n  function isContinuedStatement(state, textAfter) {\r\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\r\n      isOperatorChar.test(textAfter.charAt(0)) ||\r\n      /[,.]/.test(textAfter.charAt(0));\r\n  }\r\n\r\n  // Interface\r\n\r\n  return {\r\n    startState: function(basecolumn) {\r\n      var state = {\r\n        tokenize: tokenBase,\r\n        lastType: \"sof\",\r\n        cc: [],\r\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\r\n        localVars: parserConfig.localVars,\r\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\r\n        indented: basecolumn || 0\r\n      };\r\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\r\n        state.globalVars = parserConfig.globalVars;\r\n      return state;\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream.sol()) {\r\n        if (!state.lexical.hasOwnProperty(\"align\"))\r\n          state.lexical.align = false;\r\n        state.indented = stream.indentation();\r\n        findFatArrow(stream, state);\r\n      }\r\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\r\n      var style = state.tokenize(stream, state);\r\n      if (type == \"comment\") return style;\r\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\r\n      return parseJS(state, style, type, content, stream);\r\n    },\r\n\r\n    indent: function(state, textAfter) {\r\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\r\n      if (state.tokenize != tokenBase) return 0;\r\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\r\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\r\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\r\n        var c = state.cc[i];\r\n        if (c == poplex) lexical = lexical.prev;\r\n        else if (c != maybeelse) break;\r\n      }\r\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\r\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\r\n        lexical = lexical.prev;\r\n      var type = lexical.type, closing = firstChar == type;\r\n\r\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\r\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\r\n      else if (type == \"form\") return lexical.indented + indentUnit;\r\n      else if (type == \"stat\")\r\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\r\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\r\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\r\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\r\n      else return lexical.indented + (closing ? 0 : indentUnit);\r\n    },\r\n\r\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\r\n    blockCommentStart: jsonMode ? null : \"/*\",\r\n    blockCommentEnd: jsonMode ? null : \"*/\",\r\n    lineComment: jsonMode ? null : \"//\",\r\n    fold: \"brace\",\r\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\r\n\r\n    helperType: jsonMode ? \"json\" : \"javascript\",\r\n    jsonldMode: jsonldMode,\r\n    jsonMode: jsonMode,\r\n\r\n    expressionAllowed: expressionAllowed,\r\n    skipExpression: function(state) {\r\n      var top = state.cc[state.cc.length - 1]\r\n      if (top == expression || top == expressionNoComma) state.cc.pop()\r\n    }\r\n  };\r\n});\r\n\r\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\r\n\r\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\r\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\r\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\r\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\r\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\r\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\r\n\r\n});\r\n"]}